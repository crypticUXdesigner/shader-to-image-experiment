{
  "helpItems": {
    "node:uv-coordinates": {
      "title": "UV Coords",
      "titleType": "node",
      "category": "Inputs",
      "icon": "chart-scatter",
      "tagline": "Perfect for accessing normalized screen-space coordinates for texture sampling and pattern generation",
      "description": "Outputs normalized UV coordinates (0-1 range) representing the current fragment's position on the screen. These coordinates are automatically normalized from screen space, making them ideal for texture mapping, pattern generation, and coordinate-based effects. The output is a vec2 where x and y range from 0.0 to 1.0, with (0,0) typically at the bottom-left and (1,1) at the top-right of the screen.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Normalized UV coordinates in the range 0.0 to 1.0",
          "suggestedTargets": ["node:translate", "node:scale", "node:rotate", "node:multiply", "node:fbm-noise", "node:simplex-noise", "node:hexagonal-grid", "node:wave-patterns"]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:fragment-coordinates",
        "node:resolution"
      ]
    },
    "node:time": {
      "title": "Time",
      "titleType": "node",
      "category": "Inputs",
      "icon": "time-clock",
      "tagline": "Ideal for creating time-based animations and dynamic effects that evolve over time",
      "description": "Outputs the current time value as a float, continuously increasing from the start of the shader execution. This value is perfect for animating values, creating oscillating effects, and driving time-dependent transformations. The time value increases linearly and can be used with trigonometric functions (sine, cosine) to create smooth, repeating animations.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The current time value, continuously increasing from shader start",
          "suggestedTargets": ["node:sine", "node:cosine", "node:multiply", "node:fbm-noise", "node:wave-patterns", "node:scanlines", "node:particle-system"]
        }
      ],
      "relatedItems": [
        "type:float",
        "node:sine",
        "node:cosine",
        "node:multiply"
      ]
    },
    "node:resolution": {
      "title": "Resolution",
      "titleType": "node",
      "category": "Inputs",
      "icon": "chart-scatter",
      "tagline": "Use this to access screen resolution for aspect ratio calculations and pixel-perfect effects",
      "description": "Outputs the screen resolution as a vec2 containing the width and height in pixels. This is essential for maintaining aspect ratios, calculating pixel sizes, and creating resolution-independent effects. The x component represents width, and the y component represents height.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Screen resolution as (width, height) in pixels",
          "suggestedTargets": ["node:divide", "node:uv-coordinates", "node:polar-coordinates", "node:bayer-dither"]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:uv-coordinates",
        "node:fragment-coordinates",
        "node:divide"
      ]
    },
    "node:fragment-coordinates": {
      "title": "Frag Coords",
      "titleType": "node",
      "category": "Inputs",
      "icon": "chart-scatter",
      "tagline": "Perfect for accessing raw pixel coordinates for pixel-level effects and precise positioning",
      "description": "Outputs the fragment coordinates (gl_FragCoord.xy) as a vec2, representing the actual pixel position on the screen. Unlike UV coordinates which are normalized, fragment coordinates are in actual pixel units, with (0,0) at the bottom-left corner. This is useful for pixel-perfect effects, precise positioning, and calculations that require actual screen dimensions.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Fragment coordinates in pixel units (x, y)",
          "suggestedTargets": ["node:divide", "node:translate", "node:bayer-dither", "node:polar-coordinates"]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:uv-coordinates",
        "node:resolution"
      ]
    },
    "node:constant-float": {
      "title": "Float",
      "titleType": "node",
      "category": "Inputs",
      "icon": "constant",
      "tagline": "Use this to provide a constant float value for parameters, thresholds, and numeric inputs",
      "description": "Outputs a constant float value that can be adjusted via a parameter. This node is essential for providing fixed numeric values to other nodes, such as thresholds, multipliers, offsets, and any scalar parameter. The value can be set between -1000.0 and 1000.0 with fine control via the parameter slider.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The constant float value set by the parameter",
          "suggestedTargets": ["node:add", "node:multiply", "node:mix", "node:sine", "node:clamp", "node:remap", "node:translate", "node:scale"]
        }
      ],
      "relatedItems": [
        "type:float",
        "node:constant-vec2",
        "node:constant-vec3",
        "node:constant-vec4"
      ]
    },
    "node:constant-vec2": {
      "title": "Vec2",
      "titleType": "node",
      "category": "Inputs",
      "icon": "chart-scatter",
      "tagline": "Ideal for providing constant 2D vectors for coordinates, offsets, and 2D parameters",
      "description": "Outputs a constant vec2 value with adjustable x and y components. This node is perfect for providing fixed 2D values such as coordinate offsets, scale factors, translation amounts, or any pair of related float values. Both x and y components can be independently adjusted between -1000.0 and 1000.0.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The constant vec2 value with (x, y) components",
          "suggestedTargets": ["node:translate", "node:scale", "node:rotate", "node:uv-coordinates", "node:add", "node:multiply"]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:constant-float",
        "node:constant-vec3",
        "node:constant-vec4"
      ]
    },
    "node:constant-vec3": {
      "title": "Vec3",
      "titleType": "node",
      "category": "Inputs",
      "icon": "chart-scatter-3d",
      "tagline": "Perfect for providing constant 3D vectors for positions, directions, or RGB color values",
      "description": "Outputs a constant vec3 value with adjustable x, y, and z components. This node is useful for providing fixed 3D values such as positions, direction vectors, RGB color values (before conversion to color nodes), or any triple of related float values. All three components can be independently adjusted between -1000.0 and 1000.0.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The constant vec3 value with (x, y, z) components",
          "suggestedTargets": ["node:oklch-color-map-bezier", "node:color-map", "node:mix", "node:normalize", "node:final-output"]
        }
      ],
      "relatedItems": [
        "type:vec3",
        "node:constant-float",
        "node:constant-vec2",
        "node:constant-vec4",
        "node:oklch-color"
      ]
    },
    "node:constant-vec4": {
      "title": "Vec4",
      "titleType": "node",
      "category": "Inputs",
      "icon": "chart-scatter-3d",
      "tagline": "Use this to provide constant 4D vectors for RGBA colors, homogeneous coordinates, or 4D data",
      "description": "Outputs a constant vec4 value with adjustable x, y, z, and w components. This node is essential for providing fixed 4D values such as RGBA color values, homogeneous coordinates for 3D transformations, or any quadruple of related float values. All four components can be independently adjusted between -1000.0 and 1000.0, with w defaulting to 1.0.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The constant vec4 value with (x, y, z, w) components",
          "suggestedTargets": ["node:mix", "node:blend-mode", "node:gradient-mask", "node:oklch-color-map-bezier"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:constant-float",
        "node:constant-vec2",
        "node:constant-vec3",
        "node:bezier-curve"
      ]
    },
    "node:oklch-color": {
      "title": "OKLCH Color",
      "titleType": "node",
      "category": "Inputs",
      "icon": "color-picker",
      "tagline": "Ideal for creating perceptually uniform colors using the OKLCH color space",
      "description": "Defines a color value in the OKLCH (OK Lightness, Chroma, Hue) color space, which provides perceptually uniform color representation. This means that equal changes in the L, C, or H values result in visually similar changes in perceived color. The node outputs a vec3 containing (L, C, H) values, where L (lightness) ranges from 0.0 to 1.0, C (chroma/saturation) ranges from 0.0 to 0.4, and H (hue) ranges from 0.0 to 360.0 degrees. This color space is particularly useful for smooth color gradients and color interpolation.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "OKLCH color value as (lightness, chroma, hue)",
          "suggestedTargets": ["node:oklch-color-map-bezier", "node:oklch-color-map-threshold", "node:color-map", "node:mix"]
        }
      ],
      "relatedItems": [
        "type:vec3",
        "node:oklch-color-map-bezier",
        "node:oklch-color-map-threshold",
        "node:constant-vec3"
      ]
    },
    "node:bezier-curve": {
      "title": "Bezier",
      "titleType": "node",
      "category": "Inputs",
      "icon": "ease-in-out-control-points",
      "tagline": "Perfect for defining smooth easing curves for color interpolation and animation timing",
      "description": "Defines a cubic Bezier curve for smooth interpolation and easing functions. The node outputs a vec4 containing the two control points (x1, y1, x2, y2) that define the curve's shape. This curve can be used with color mapping nodes to create smooth color transitions, or with animation systems to define easing functions. The curve is visualized in a bezier editor interface where you can drag control points to adjust the curve shape. The curve maps input values (0-1) to output values (0-1) with customizable easing.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "Bezier curve control points as (x1, y1, x2, y2)",
          "suggestedTargets": ["node:oklch-color-map-bezier", "node:mix", "node:smoothstep"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:oklch-color-map-bezier",
        "node:constant-vec4",
        "node:mix",
        "node:smoothstep"
      ]
    },
    "node:add": {
      "title": "Add",
      "titleType": "node",
      "category": "Math",
      "icon": "plus",
      "tagline": "Perfect for combining values through addition",
      "description": "Adds two values together. Works with any numeric type (float, vec2, vec3, vec4) through type promotion. The result is the sum of both inputs, making it ideal for combining values, offsets, and accumulations.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to add",
          "suggestedSources": ["type:float", "node:constant-float", "node:time", "node:multiply", "node:sine", "node:audio-remap"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to add",
          "suggestedSources": ["type:float", "node:constant-float", "node:time", "node:multiply", "node:sine", "node:audio-remap"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The sum of both input values",
          "suggestedTargets": ["node:multiply", "node:mix", "node:translate", "node:final-output", "node:remap", "node:clamp"]
        }
      ],
      "relatedItems": [
        "node:subtract",
        "node:multiply",
        "node:divide",
        "type:float"
      ]
    },
    "node:subtract": {
      "title": "Subtract",
      "titleType": "node",
      "category": "Math",
      "icon": "minus",
      "tagline": "Ideal for calculating differences and offsets",
      "description": "Subtracts the second value from the first. Works with any numeric type through type promotion. Useful for calculating differences, applying negative offsets, and creating distance-based effects.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The value to subtract from",
          "suggestedSources": ["type:float", "node:constant-float", "node:time", "node:add", "node:multiply", "node:uv-coordinates"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The value to subtract",
          "suggestedSources": ["type:float", "node:constant-float", "node:time", "node:add", "node:multiply"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The difference between the two values",
          "suggestedTargets": ["node:add", "node:multiply", "node:absolute", "node:distance", "node:clamp", "node:remap"]
        }
      ],
      "relatedItems": [
        "node:add",
        "node:multiply",
        "node:divide",
        "type:float"
      ]
    },
    "node:multiply": {
      "title": "Multiply",
      "titleType": "node",
      "category": "Math",
      "icon": "multiply-x",
      "tagline": "Use this to scale values and combine intensities",
      "description": "Multiplies two values together. Works with any numeric type through type promotion. Essential for scaling values, applying intensity multipliers, and combining color channels.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to multiply",
          "suggestedSources": ["type:float", "node:constant-float", "node:time", "node:add", "node:sine", "node:uv-coordinates"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to multiply",
          "suggestedSources": ["type:float", "node:constant-float", "node:time", "node:add", "node:sine"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The product of both input values",
          "suggestedTargets": ["node:add", "node:mix", "node:translate", "node:final-output", "node:color-map", "node:remap"]
        }
      ],
      "relatedItems": [
        "node:add",
        "node:divide",
        "node:power",
        "type:float"
      ]
    },
    "node:divide": {
      "title": "Divide",
      "titleType": "node",
      "category": "Math",
      "icon": "divide",
      "tagline": "Perfect for normalizing values and calculating ratios",
      "description": "Divides the first value by the second. Works with any numeric type through type promotion. Useful for normalization, calculating ratios, and inverting scales. Be careful to avoid division by zero.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The dividend (value to be divided)",
          "suggestedSources": ["type:float", "node:constant-float", "node:fragment-coordinates", "node:resolution", "node:length", "node:distance"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The divisor (value to divide by)",
          "suggestedSources": ["type:float", "node:constant-float", "node:resolution", "node:length"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The quotient of the division",
          "suggestedTargets": ["node:multiply", "node:add", "node:uv-coordinates", "node:remap", "node:polar-coordinates"]
        }
      ],
      "relatedItems": [
        "node:multiply",
        "node:reciprocal",
        "type:float"
      ]
    },
    "node:power": {
      "title": "Power",
      "titleType": "node",
      "category": "Math",
      "icon": "power",
      "tagline": "Ideal for exponential curves and non-linear transformations",
      "description": "Raises the base value to the power of the exponent. Useful for creating exponential curves, gamma corrections, and non-linear transformations. The exponent can be fractional for roots.",
      "inputs": [
        {
          "name": "base",
          "type": "float",
          "description": "The base value to raise to a power",
          "suggestedSources": ["type:float", "node:constant-float", "node:add", "node:multiply", "node:smoothstep", "node:fbm-noise"]
        },
        {
          "name": "exponent",
          "type": "float",
          "description": "The exponent to raise the base to",
          "suggestedSources": ["type:float", "node:constant-float", "node:divide"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The result of base raised to the exponent",
          "suggestedTargets": ["node:multiply", "node:mix", "node:color-map", "node:remap", "node:clamp"]
        }
      ],
      "relatedItems": [
        "node:square-root",
        "node:exponential",
        "type:float"
      ]
    },
    "node:square-root": {
      "title": "Square Root",
      "titleType": "node",
      "category": "Math",
      "icon": "sqrt",
      "tagline": "Use this to calculate square roots and normalize distances",
      "description": "Calculates the square root of the input value. Commonly used for distance calculations, normalizing magnitudes, and creating smooth falloff curves. The square root is equivalent to raising a value to the power of 0.5.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to calculate the square root of",
          "suggestedSources": ["type:float", "node:length", "node:distance", "node:dot-product", "node:multiply"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The square root of the input value",
          "suggestedTargets": ["node:length", "node:normalize", "node:distance", "node:multiply", "node:mix"]
        }
      ],
      "relatedItems": [
        "node:power",
        "node:length",
        "node:distance",
        "type:float"
      ]
    },
    "node:absolute": {
      "title": "Absolute",
      "titleType": "node",
      "category": "Math",
      "icon": "arrows-left-right",
      "tagline": "Perfect for removing negative values and calculating magnitudes",
      "description": "Returns the absolute value of the input, removing any negative sign. Useful for distance calculations, ensuring positive values, and working with differences where direction doesn't matter.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to get the absolute value of",
          "suggestedSources": ["type:float", "node:subtract", "node:sine", "node:fbm-noise", "node:distance"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The absolute value (always positive or zero)",
          "suggestedTargets": ["node:multiply", "node:mix", "node:length", "node:clamp", "node:remap"]
        }
      ],
      "relatedItems": [
        "node:sign",
        "node:negate",
        "type:float"
      ]
    },
    "node:floor": {
      "title": "Floor",
      "titleType": "node",
      "category": "Math",
      "icon": "arrow-down",
      "tagline": "Ideal for rounding down to the nearest integer",
      "description": "Rounds the input value down to the nearest integer. Useful for creating discrete steps, grid-based effects, and quantizing values. Always rounds towards negative infinity.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to round down",
          "suggestedSources": ["type:float", "node:constant-float", "node:multiply", "node:fract", "node:uv-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The largest integer less than or equal to the input",
          "suggestedTargets": ["node:add", "node:multiply", "node:hexagonal-grid", "node:plane-grid", "node:modulo"]
        }
      ],
      "relatedItems": [
        "node:ceil",
        "node:round",
        "node:fract",
        "type:float"
      ]
    },
    "node:ceil": {
      "title": "Ceil",
      "titleType": "node",
      "category": "Math",
      "icon": "arrow-up",
      "tagline": "Use this to round up to the nearest integer",
      "description": "Rounds the input value up to the nearest integer. Useful for creating discrete steps, grid-based effects, and quantizing values. Always rounds towards positive infinity.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to round up",
          "suggestedSources": ["type:float", "node:constant-float", "node:multiply", "node:fract", "node:divide"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The smallest integer greater than or equal to the input",
          "suggestedTargets": ["node:add", "node:multiply", "node:hexagonal-grid", "node:modulo"]
        }
      ],
      "relatedItems": [
        "node:floor",
        "node:round",
        "node:fract",
        "type:float"
      ]
    },
    "node:fract": {
      "title": "Fract",
      "titleType": "node",
      "category": "Math",
      "icon": "hash",
      "tagline": "Perfect for extracting fractional parts and creating repeating patterns",
      "description": "Returns the fractional part of the input value (the part after the decimal point). Essential for creating repeating patterns, tiling effects, and extracting the decimal portion of values. The result is always between 0.0 and 1.0.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to extract the fractional part from",
          "suggestedSources": ["type:float", "node:multiply", "node:uv-coordinates", "node:time", "node:distance", "node:length"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The fractional part (always 0.0 to 1.0)",
          "suggestedTargets": ["node:hexagonal-grid", "node:plane-grid", "node:rings", "node:smoothstep", "node:mix", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:floor",
        "node:ceil",
        "node:modulo",
        "type:float"
      ]
    },
    "node:modulo": {
      "title": "Modulo",
      "titleType": "node",
      "category": "Math",
      "icon": "percentage",
      "tagline": "Ideal for creating repeating cycles and wrapping values",
      "description": "Calculates the remainder after dividing the first value by the second. Essential for creating repeating patterns, wrapping values within a range, and implementing cyclic behaviors. The result is always between 0.0 and the divisor.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The dividend value",
          "suggestedSources": ["type:float", "node:time", "node:uv-coordinates", "node:multiply", "node:add"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The divisor value",
          "suggestedSources": ["type:float", "node:constant-float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The remainder of the division",
          "suggestedTargets": ["node:sine", "node:cosine", "node:fract", "node:smoothstep", "node:rings"]
        }
      ],
      "relatedItems": [
        "node:divide",
        "node:fract",
        "type:float"
      ]
    },
    "node:min": {
      "title": "Min",
      "titleType": "node",
      "category": "Math",
      "icon": "math-min",
      "tagline": "Use this to find the smaller of two values",
      "description": "Returns the minimum (smaller) of two input values. Useful for clamping values from above, finding the lower bound, and implementing conditional logic based on value comparisons.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to compare",
          "suggestedSources": ["type:float", "node:constant-float", "node:add", "node:multiply", "node:smoothstep"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to compare",
          "suggestedSources": ["type:float", "node:constant-float", "node:add", "node:multiply"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The smaller of the two input values",
          "suggestedTargets": ["node:clamp", "node:mix", "node:max", "node:remap", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:max",
        "node:clamp",
        "type:float"
      ]
    },
    "node:max": {
      "title": "Max",
      "titleType": "node",
      "category": "Math",
      "icon": "math-max",
      "tagline": "Perfect for finding the larger of two values",
      "description": "Returns the maximum (larger) of two input values. Useful for clamping values from below, finding the upper bound, and implementing conditional logic based on value comparisons.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to compare",
          "suggestedSources": ["type:float", "node:constant-float", "node:add", "node:multiply", "node:sine"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to compare",
          "suggestedSources": ["type:float", "node:constant-float", "node:add", "node:multiply"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The larger of the two input values",
          "suggestedTargets": ["node:clamp", "node:mix", "node:min", "node:remap", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:min",
        "node:clamp",
        "type:float"
      ]
    },
    "node:clamp": {
      "title": "Clamp",
      "titleType": "node",
      "category": "Math",
      "icon": "math-max-min",
      "tagline": "Ideal for constraining values within a specific range",
      "description": "Clamps the input value between a minimum and maximum. If the value is below the minimum, it returns the minimum. If above the maximum, it returns the maximum. Otherwise, it returns the original value. Essential for keeping values within valid ranges.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to clamp",
          "suggestedSources": ["type:float", "node:add", "node:multiply", "node:sine", "node:fbm-noise", "node:audio-remap"]
        },
        {
          "name": "min",
          "type": "float",
          "description": "The minimum allowed value",
          "suggestedSources": ["type:float", "node:constant-float"]
        },
        {
          "name": "max",
          "type": "float",
          "description": "The maximum allowed value",
          "suggestedSources": ["type:float", "node:constant-float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The clamped value (between min and max)",
          "suggestedTargets": ["node:mix", "node:remap", "node:color-map", "node:final-output", "node:smoothstep"]
        }
      ],
      "relatedItems": [
        "node:min",
        "node:max",
        "node:clamp-01",
        "node:saturate",
        "type:float"
      ]
    },
    "node:mix": {
      "title": "Mix",
      "titleType": "node",
      "category": "Math",
      "icon": "arrows-left-right",
      "tagline": "Perfect for linear interpolation between two values",
      "description": "Performs linear interpolation between two values based on a blend factor. When the blend factor is 0.0, it returns the first value. When it's 1.0, it returns the second value. Values in between are linearly interpolated. Works with any numeric type.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value (returned when t = 0.0)",
          "suggestedSources": ["type:float", "node:constant-float", "node:sine", "node:add", "node:fbm-noise"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value (returned when t = 1.0)",
          "suggestedSources": ["type:float", "node:constant-float", "node:sine", "node:add", "node:fbm-noise"]
        },
        {
          "name": "t",
          "type": "float",
          "description": "The blend factor (typically 0.0 to 1.0)",
          "suggestedSources": ["type:float", "node:constant-float", "node:smoothstep", "node:uv-coordinates", "node:audio-remap"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The interpolated value between a and b",
          "suggestedTargets": ["node:final-output", "node:color-map", "node:blend-mode", "node:translate", "node:scale"]
        }
      ],
      "relatedItems": [
        "node:lerp",
        "node:smoothstep",
        "type:float"
      ]
    },
    "node:step": {
      "title": "Step",
      "titleType": "node",
      "category": "Math",
      "icon": "arrow-right",
      "tagline": "Use this to create hard thresholds and binary decisions",
      "description": "Returns 0.0 if the input value is less than the edge value, otherwise returns 1.0. Creates a hard step function that's useful for creating binary masks, thresholds, and on/off switches based on value comparisons.",
      "inputs": [
        {
          "name": "edge",
          "type": "float",
          "description": "The threshold value to compare against",
          "suggestedSources": ["type:float", "node:constant-float", "node:smoothstep", "node:remap"]
        },
        {
          "name": "x",
          "type": "float",
          "description": "The value to compare with the edge",
          "suggestedSources": ["type:float", "node:fbm-noise", "node:distance", "node:sine", "node:uv-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "0.0 if x < edge, 1.0 otherwise",
          "suggestedTargets": ["node:mix", "node:select", "node:compare", "node:gradient-mask", "node:oklch-color-map-threshold"]
        }
      ],
      "relatedItems": [
        "node:smoothstep",
        "node:compare",
        "type:float"
      ]
    },
    "node:smoothstep": {
      "title": "Smoothstep",
      "titleType": "node",
      "category": "Math",
      "icon": "wave-sine",
      "tagline": "Ideal for creating smooth transitions with ease-in-out curves",
      "description": "Performs smooth Hermite interpolation between two edge values. Returns 0.0 if the input is below edge0, 1.0 if above edge1, and smoothly interpolates between them. Creates an S-curve that's perfect for smooth transitions, fades, and easing functions.",
      "inputs": [
        {
          "name": "edge0",
          "type": "float",
          "description": "The lower edge of the transition (returns 0.0 below this)",
          "suggestedSources": ["type:float", "node:constant-float", "node:remap"]
        },
        {
          "name": "edge1",
          "type": "float",
          "description": "The upper edge of the transition (returns 1.0 above this)",
          "suggestedSources": ["type:float", "node:constant-float", "node:remap"]
        },
        {
          "name": "x",
          "type": "float",
          "description": "The input value to evaluate",
          "suggestedSources": ["type:float", "node:fbm-noise", "node:distance", "node:sine", "node:uv-coordinates", "node:fract"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Smoothly interpolated value between 0.0 and 1.0",
          "suggestedTargets": ["node:mix", "node:color-map", "node:gradient-mask", "node:twist-distortion", "node:translate"]
        }
      ],
      "relatedItems": [
        "node:step",
        "node:mix",
        "node:lerp",
        "type:float"
      ]
    },
    "node:sine": {
      "title": "Sine",
      "titleType": "node",
      "category": "Math",
      "icon": "trig-wave",
      "tagline": "Perfect for creating oscillating waves and periodic animations",
      "description": "Calculates the sine of the input angle (in radians). Returns values between -1.0 and 1.0, creating a smooth oscillating wave. Essential for creating periodic animations, waves, circular motion, and oscillating effects.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The angle in radians",
          "suggestedSources": ["type:float", "node:time", "node:multiply", "node:constant-float", "node:uv-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The sine value (between -1.0 and 1.0)",
          "suggestedTargets": ["node:add", "node:multiply", "node:mix", "node:wave-patterns", "node:translate", "node:rotate"]
        }
      ],
      "relatedItems": [
        "node:cosine",
        "node:tangent",
        "node:time",
        "type:float"
      ]
    },
    "node:cosine": {
      "title": "Cosine",
      "titleType": "node",
      "category": "Math",
      "icon": "math-cos",
      "tagline": "Use this for oscillating waves with a phase offset",
      "description": "Calculates the cosine of the input angle (in radians). Returns values between -1.0 and 1.0, creating a smooth oscillating wave that's phase-shifted by 90 degrees from sine. Useful for circular motion, rotations, and periodic effects.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The angle in radians",
          "suggestedSources": ["type:float", "node:time", "node:multiply", "node:constant-float", "node:arc-tangent-2", "node:uv-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The cosine value (between -1.0 and 1.0)",
          "suggestedTargets": ["node:add", "node:multiply", "node:mix", "node:wave-patterns", "node:rotate", "node:vector-field"]
        }
      ],
      "relatedItems": [
        "node:sine",
        "node:tangent",
        "node:time",
        "type:float"
      ]
    },
    "node:tangent": {
      "title": "Tangent",
      "titleType": "node",
      "category": "Math",
      "icon": "math-tg",
      "tagline": "Ideal for calculating slopes and ratios in trigonometry",
      "description": "Calculates the tangent of the input angle (in radians). The tangent is the ratio of sine to cosine. Returns values from negative to positive infinity, with discontinuities at odd multiples of π/2. Useful for advanced trigonometric calculations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The angle in radians",
          "suggestedSources": ["type:float", "node:time", "node:arc-tangent-2", "node:constant-float", "node:uv-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The tangent value",
          "suggestedTargets": ["node:arc-tangent", "node:multiply", "node:add", "node:mix"]
        }
      ],
      "relatedItems": [
        "node:sine",
        "node:cosine",
        "node:arc-tangent",
        "type:float"
      ]
    },
    "node:arc-sine": {
      "title": "Arc Sine",
      "titleType": "node",
      "category": "Math",
      "icon": "math-function-y",
      "tagline": "Perfect for converting sine values back to angles",
      "description": "Calculates the inverse sine (arcsine) of the input value. Returns an angle in radians between -π/2 and π/2. The input must be between -1.0 and 1.0. Useful for converting sine values back to angles and solving trigonometric equations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The sine value (must be between -1.0 and 1.0)",
          "suggestedSources": ["type:float", "node:sine", "node:cosine", "node:clamp", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between -π/2 and π/2)",
          "suggestedTargets": ["node:sine", "node:cosine", "node:rotate", "node:multiply"]
        }
      ],
      "relatedItems": [
        "node:sine",
        "node:arc-cosine",
        "node:arc-tangent",
        "type:float"
      ]
    },
    "node:arc-cosine": {
      "title": "Arc Cosine",
      "titleType": "node",
      "category": "Math",
      "icon": "math-function-y",
      "tagline": "Use this to convert cosine values back to angles",
      "description": "Calculates the inverse cosine (arccosine) of the input value. Returns an angle in radians between 0.0 and π. The input must be between -1.0 and 1.0. Useful for converting cosine values back to angles and solving trigonometric equations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The cosine value (must be between -1.0 and 1.0)",
          "suggestedSources": ["type:float", "node:sine", "node:cosine", "node:dot-product", "node:clamp"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between 0.0 and π)",
          "suggestedTargets": ["node:sine", "node:cosine", "node:rotate", "node:multiply"]
        }
      ],
      "relatedItems": [
        "node:cosine",
        "node:arc-sine",
        "node:arc-tangent",
        "type:float"
      ]
    },
    "node:arc-tangent": {
      "title": "Arc Tangent",
      "titleType": "node",
      "category": "Math",
      "icon": "math-function-y",
      "tagline": "Ideal for converting tangent values to angles",
      "description": "Calculates the inverse tangent (arctangent) of the input value. Returns an angle in radians between -π/2 and π/2. Useful for converting slopes and ratios back to angles, but limited to two quadrants. For full 360-degree coverage, use Arc Tangent 2.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The tangent value (ratio)",
          "suggestedSources": ["type:float", "node:tangent", "node:divide", "node:constant-float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between -π/2 and π/2)",
          "suggestedTargets": ["node:sine", "node:cosine", "node:rotate", "node:multiply"]
        }
      ],
      "relatedItems": [
        "node:tangent",
        "node:arc-tangent-2",
        "type:float"
      ]
    },
    "node:arc-tangent-2": {
      "title": "Arc Tangent 2",
      "titleType": "node",
      "category": "Math",
      "icon": "math-symbols",
      "tagline": "Perfect for converting coordinates to angles with full quadrant support",
      "description": "Calculates the angle from the x-axis to a point given by (x, y) coordinates. Returns an angle in radians between -π and π, covering all four quadrants. Essential for converting 2D coordinates to angles, calculating directions, and working with polar coordinates.",
      "inputs": [
        {
          "name": "y",
          "type": "float",
          "description": "The y-coordinate of the point",
          "suggestedSources": ["type:float", "node:split-vector", "node:uv-coordinates", "node:polar-coordinates", "node:constant-float"]
        },
        {
          "name": "x",
          "type": "float",
          "description": "The x-coordinate of the point",
          "suggestedSources": ["type:float", "node:split-vector", "node:uv-coordinates", "node:polar-coordinates", "node:constant-float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between -π and π)",
          "suggestedTargets": ["node:rotate", "node:sine", "node:cosine", "node:kaleidoscope", "node:polar-coordinates"]
        }
      ],
      "relatedItems": [
        "node:arc-tangent",
        "node:rotate",
        "type:float",
        "type:vec2"
      ]
    },
    "node:exponential": {
      "title": "Exponential",
      "titleType": "node",
      "category": "Math",
      "icon": "math-xy",
      "tagline": "Use this for exponential growth and decay curves",
      "description": "Calculates e (Euler's number, approximately 2.718) raised to the power of the input. Creates exponential growth curves when the input is positive and exponential decay when negative. Useful for natural growth/decay effects, logarithmic scales, and advanced mathematical operations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The exponent to raise e to",
          "suggestedSources": ["type:float", "node:time", "node:multiply", "node:natural-logarithm", "node:sine"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "e raised to the power of the input",
          "suggestedTargets": ["node:natural-logarithm", "node:multiply", "node:mix", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:natural-logarithm",
        "node:power",
        "type:float"
      ]
    },
    "node:natural-logarithm": {
      "title": "Natural Logarithm",
      "titleType": "node",
      "category": "Math",
      "icon": "math-function",
      "tagline": "Ideal for inverting exponential functions and logarithmic scales",
      "description": "Calculates the natural logarithm (base e) of the input value. The input must be greater than zero. This is the inverse of the exponential function. Useful for compressing large value ranges, inverting exponential curves, and working with logarithmic scales.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to calculate the logarithm of (must be > 0)",
          "suggestedSources": ["type:float", "node:exponential", "node:distance", "node:length", "node:add"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The natural logarithm of the input",
          "suggestedTargets": ["node:exponential", "node:multiply", "node:power", "node:remap"]
        }
      ],
      "relatedItems": [
        "node:exponential",
        "node:power",
        "type:float"
      ]
    },
    "node:length": {
      "title": "Length",
      "titleType": "node",
      "category": "Math",
      "icon": "ruler",
      "tagline": "Perfect for calculating vector magnitudes and distances from origin",
      "description": "Calculates the length (magnitude) of a vector. For a 2D vector, this is the distance from the origin (0,0) to the point. Essential for distance calculations, normalizing vectors, and working with vector magnitudes.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The vector to calculate the length of",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:polar-coordinates", "node:constant-vec2"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The magnitude (length) of the vector",
          "suggestedTargets": ["node:normalize", "node:distance", "node:smoothstep", "node:rings", "node:gradient-mask"]
        }
      ],
      "relatedItems": [
        "node:distance",
        "node:normalize",
        "node:square-root",
        "type:vec2"
      ]
    },
    "node:distance": {
      "title": "Distance",
      "titleType": "node",
      "category": "Math",
      "icon": "ruler",
      "tagline": "Use this to calculate the distance between two points",
      "description": "Calculates the Euclidean distance between two points. Returns the length of the vector from point a to point b. Essential for proximity-based effects, radial gradients, and spatial calculations.",
      "inputs": [
        {
          "name": "a",
          "type": "vec2",
          "description": "The first point",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:constant-vec2"]
        },
        {
          "name": "b",
          "type": "vec2",
          "description": "The second point",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:constant-vec2", "node:translate"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The distance between the two points",
          "suggestedTargets": ["node:smoothstep", "node:gradient-mask", "node:rings", "node:voronoi-noise", "node:sphere-raymarch"]
        }
      ],
      "relatedItems": [
        "node:length",
        "node:normalize",
        "type:vec2"
      ]
    },
    "node:dot-product": {
      "title": "Dot Product",
      "titleType": "node",
      "category": "Math",
      "icon": "vector-dot",
      "tagline": "Ideal for calculating angles, projections, and lighting",
      "description": "Calculates the dot product of two vectors. Returns a scalar value that represents the cosine of the angle between vectors (when normalized) multiplied by their lengths. Essential for lighting calculations, angle measurements, and vector projections.",
      "inputs": [
        {
          "name": "a",
          "type": "vec2",
          "description": "The first vector",
          "suggestedSources": ["type:vec2", "node:normalize", "node:uv-coordinates", "node:lighting-shading", "node:constant-vec2"]
        },
        {
          "name": "b",
          "type": "vec2",
          "description": "The second vector",
          "suggestedSources": ["type:vec2", "node:normalize", "node:normal-mapping", "node:constant-vec2"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The dot product of the two vectors",
          "suggestedTargets": ["node:lighting-shading", "node:mix", "node:smoothstep", "node:color-map", "node:vector-field"]
        }
      ],
      "relatedItems": [
        "node:cross-product",
        "node:normalize",
        "type:vec2"
      ]
    },
    "node:cross-product": {
      "title": "Cross Product",
      "titleType": "node",
      "category": "Math",
      "icon": "vector-cross",
      "tagline": "Perfect for calculating perpendicular vectors and surface normals",
      "description": "Calculates the cross product of two 3D vectors. Returns a vector perpendicular to both input vectors, with magnitude equal to the area of the parallelogram they form. Essential for calculating surface normals, determining orientation, and 3D vector mathematics.",
      "inputs": [
        {
          "name": "a",
          "type": "vec3",
          "description": "The first 3D vector",
          "suggestedSources": ["type:vec3", "node:normalize", "node:normal-mapping", "node:constant-vec3"]
        },
        {
          "name": "b",
          "type": "vec3",
          "description": "The second 3D vector",
          "suggestedSources": ["type:vec3", "node:normalize", "node:normal-mapping", "node:constant-vec3"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The cross product vector (perpendicular to both inputs)",
          "suggestedTargets": ["node:normalize", "node:normal-mapping", "node:lighting-shading"]
        }
      ],
      "relatedItems": [
        "node:dot-product",
        "node:normalize",
        "type:vec3"
      ]
    },
    "node:normalize": {
      "title": "Normalize",
      "titleType": "node",
      "category": "Math",
      "icon": "normalize",
      "tagline": "Use this to create unit vectors with length 1.0",
      "description": "Normalizes a vector to unit length (magnitude of 1.0) while preserving its direction. The result points in the same direction as the input but has a length of exactly 1.0. Essential for direction vectors, normals, and any calculations requiring unit vectors.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The vector to normalize",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:polar-coordinates", "node:distance"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The normalized vector (length = 1.0)",
          "suggestedTargets": ["node:dot-product", "node:reflect", "node:refract", "node:vector-field", "node:lighting-shading"]
        }
      ],
      "relatedItems": [
        "node:length",
        "node:distance",
        "node:dot-product",
        "type:vec2"
      ]
    },
    "node:reflect": {
      "title": "Reflect",
      "titleType": "node",
      "category": "Math",
      "icon": "calculator",
      "tagline": "Ideal for calculating reflection vectors for lighting and mirrors",
      "description": "Calculates the reflection of an incident vector off a surface with a given normal. The result is the direction the vector would bounce after hitting the surface. Essential for specular reflections, mirror effects, and physically-based lighting calculations.",
      "inputs": [
        {
          "name": "I",
          "type": "vec2",
          "description": "The incident vector (direction hitting the surface)",
          "suggestedSources": ["type:vec2", "node:normalize", "node:uv-coordinates", "node:normal-mapping"]
        },
        {
          "name": "N",
          "type": "vec2",
          "description": "The surface normal vector (should be normalized)",
          "suggestedSources": ["type:vec2", "node:normalize", "node:normal-mapping", "node:constant-vec2"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The reflected vector direction",
          "suggestedTargets": ["node:dot-product", "node:lighting-shading", "node:normalize"]
        }
      ],
      "relatedItems": [
        "node:refract",
        "node:normalize",
        "node:dot-product",
        "type:vec2"
      ]
    },
    "node:refract": {
      "title": "Refract",
      "titleType": "node",
      "category": "Math",
      "icon": "calculator",
      "tagline": "Perfect for calculating refraction through transparent materials",
      "description": "Calculates the refracted vector when light passes through a surface with different indices of refraction. The eta parameter is the ratio of the first medium's index to the second medium's index. Essential for realistic glass, water, and transparent material effects.",
      "inputs": [
        {
          "name": "I",
          "type": "vec2",
          "description": "The incident vector (direction entering the surface)",
          "suggestedSources": ["type:vec2", "node:normalize", "node:uv-coordinates", "node:normal-mapping"]
        },
        {
          "name": "N",
          "type": "vec2",
          "description": "The surface normal vector (should be normalized)",
          "suggestedSources": ["type:vec2", "node:normalize", "node:normal-mapping", "node:constant-vec2"]
        },
        {
          "name": "eta",
          "type": "float",
          "description": "The ratio of indices of refraction (n1/n2)",
          "suggestedSources": ["type:float", "node:constant-float", "node:divide"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The refracted vector direction",
          "suggestedTargets": ["node:normalize", "node:dot-product", "node:lighting-shading"]
        }
      ],
      "relatedItems": [
        "node:reflect",
        "node:normalize",
        "type:vec2"
      ]
    },
    "node:audio-file-input": {
      "title": "Audio File",
      "titleType": "node",
      "category": "Audio",
      "icon": "audio-waveform",
      "tagline": "Perfect for loading and playing MP3 audio files to drive audio-reactive shaders",
      "description": "Loads and plays MP3 audio files, providing real-time playback state and timing information. This node serves as the entry point for audio-reactive effects, making audio data available to other nodes in the graph. The node handles file loading, playback control, and exposes timing information that can be used to synchronize visual effects with audio playback.",
      "inputs": [],
      "outputs": [
        {
          "name": "currentTime",
          "type": "float",
          "description": "The current playback time in seconds, useful for synchronizing animations with audio position",
          "suggestedTargets": ["node:audio-analyzer", "node:multiply", "node:modulo", "node:sine", "node:remap"]
        },
        {
          "name": "duration",
          "type": "float",
          "description": "The total duration of the loaded audio file in seconds",
          "suggestedTargets": ["node:divide", "node:remap", "node:audio-remap"]
        },
        {
          "name": "isPlaying",
          "type": "float",
          "description": "Returns 1.0 when audio is playing, 0.0 when paused or stopped",
          "suggestedTargets": ["node:mix", "node:multiply", "node:step"]
        }
      ],
      "relatedItems": [
        "node:audio-analyzer",
        "node:audio-remap"
      ]
    },
    "node:audio-analyzer": {
      "title": "Audio Analyzer",
      "titleType": "node",
      "category": "Audio",
      "icon": "audio-waveform",
      "tagline": "Ideal for extracting frequency bands from audio using FFT analysis for reactive visual effects",
      "description": "Analyzes audio frequencies using Fast Fourier Transform (FFT) and extracts user-defined frequency bands. This node connects to an Audio File Input node and provides real-time frequency data that can be used to drive visual effects. You can configure custom frequency bands (like bass, mid, treble) and adjust smoothing to control how quickly the values respond to audio changes. The node outputs individual band values that represent the amplitude of each frequency range.",
      "inputs": [
        {
          "name": "audioFile",
          "type": "float",
          "description": "Connect to an Audio File Input node to provide the audio source for analysis",
          "suggestedSources": ["node:audio-file-input"]
        }
      ],
      "outputs": [
        {
          "name": "band0",
          "type": "float",
          "description": "The amplitude value for the first frequency band (typically bass frequencies)",
          "suggestedTargets": ["node:audio-remap", "node:multiply", "node:mix", "node:translate", "node:scale"]
        },
        {
          "name": "band1",
          "type": "float",
          "description": "The amplitude value for the second frequency band (typically low-mid frequencies)",
          "suggestedTargets": ["node:audio-remap", "node:multiply", "node:mix", "node:color-map"]
        },
        {
          "name": "band2",
          "type": "float",
          "description": "The amplitude value for the third frequency band (typically mid frequencies)",
          "suggestedTargets": ["node:audio-remap", "node:multiply", "node:mix"]
        },
        {
          "name": "band3",
          "type": "float",
          "description": "The amplitude value for the fourth frequency band (typically treble frequencies)",
          "suggestedTargets": ["node:audio-remap", "node:multiply", "node:mix", "node:glow-bloom"]
        }
      ],
      "relatedItems": [
        "node:audio-file-input",
        "node:audio-remap"
      ]
    },
    "node:audio-remap": {
      "title": "Audio Remap",
      "titleType": "node",
      "category": "Audio",
      "icon": "audio-waveform",
      "tagline": "Use this to remap audio values from one range to another with optional clamping",
      "description": "Remaps audio values from an input range to an output range, with optional clamping to prevent values from exceeding the output bounds. This node is optimized for audio-reactive workflows and is commonly used to convert raw frequency band values (which may vary widely) into normalized ranges suitable for driving shader parameters. The remapping uses linear interpolation between the input and output ranges, and you can enable clamping to ensure values stay within the desired output range.",
      "inputs": [
        {
          "name": "audioValue",
          "type": "float",
          "description": "The audio value to remap, typically from an Audio Analyzer band output",
          "suggestedSources": ["node:audio-analyzer", "type:float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The remapped value in the output range, ready to drive shader parameters",
          "suggestedTargets": ["node:multiply", "node:mix", "node:translate", "node:scale", "node:color-map", "node:add"]
        }
      ],
      "relatedItems": [
        "node:audio-analyzer",
        "node:remap"
      ]
    },
    "node:blend-mode": {
      "title": "Blend Mode",
      "titleType": "node",
      "category": "Blend",
      "icon": "blend-mode",
      "tagline": "Ideal for combining two values using various blend modes like multiply, screen, overlay, and more",
      "description": "Applies one of 12 different blending modes to combine a base value with a blend value. The blend modes include Normal (pass-through), Multiply, Screen, Overlay, Soft Light, Hard Light, Color Dodge, Color Burn, Linear Dodge (Add), Linear Burn, Difference, and Exclusion. Each mode produces a different visual effect when combining values. The opacity parameter controls how much of the blended result is mixed with the original base value, allowing for partial blending effects.",
      "inputs": [
        {
          "name": "base",
          "type": "float",
          "description": "The base value that will be blended with the blend input",
          "suggestedSources": ["type:float", "node:color-map", "node:oklch-color-map-bezier", "node:mix", "node:uv-coordinates"]
        },
        {
          "name": "blend",
          "type": "float",
          "description": "The value to blend with the base using the selected blend mode",
          "suggestedSources": ["type:float", "node:color-map", "node:fbm-noise", "node:mix", "node:gradient-mask"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The result of blending the base and blend inputs using the selected mode, mixed with the base according to the opacity parameter",
          "suggestedTargets": ["node:final-output", "node:mix", "node:color-grading"]
        }
      ],
      "relatedItems": [
        "type:float",
        "node:mix",
        "node:lerp"
      ]
    },
    "node:oklch-color-map-bezier": {
      "title": "Color Map Smooth",
      "titleType": "node",
      "category": "Blend",
      "icon": "ease-in-out-control-points",
      "tagline": "Perfect for converting float values to RGB colors using OKLCH color space with smooth bezier curve interpolation",
      "description": "Converts a float value (0-1) to an RGB color using the OKLCH color space with cubic bezier curve interpolation. This node provides smooth, customizable color transitions by allowing independent bezier curves for Lightness (L), Chroma (C), and Hue (H) components. The bezier curves control how each color component transitions from the start color to the end color, enabling complex color gradients with precise control over the interpolation curves. The result is converted from OKLCH to RGB for display.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The input value (0-1) to map to a color"
        },
        {
          "name": "startColor",
          "type": "vec3",
          "description": "The starting OKLCH color (L, C, H components)"
        },
        {
          "name": "endColor",
          "type": "vec3",
          "description": "The ending OKLCH color (L, C, H components)"
        },
        {
          "name": "lCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Lightness interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "cCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Chroma interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "hCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Hue interpolation (x1, y1, x2, y2)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The resulting RGB color converted from OKLCH"
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-threshold",
        "node:color-map",
        "node:oklch-color",
        "type:float",
        "type:vec3"
      ]
    },
    "node:oklch-color-map-threshold": {
      "title": "Color Map Stepped",
      "titleType": "node",
      "category": "Blend",
      "icon": "color-palette",
      "tagline": "Ideal for creating color gradients with discrete color stops and optional dithering using OKLCH color space",
      "description": "Converts a float value (0-1) to an RGB color using the OKLCH color space with threshold-based color stops. This mode creates discrete color bands with configurable transition widths between stops, allowing for stepped gradients or posterized color effects. Optional Bayer dithering can be applied to reduce banding artifacts. The node generates color stops on-the-fly based on the stops parameter, interpolating between start and end colors using bezier curves for L, C, and H components. The result is converted from OKLCH to RGB for display.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The input value (0-1) to map to a color"
        },
        {
          "name": "startColor",
          "type": "vec3",
          "description": "The starting OKLCH color (L, C, H components)"
        },
        {
          "name": "endColor",
          "type": "vec3",
          "description": "The ending OKLCH color (L, C, H components)"
        },
        {
          "name": "lCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Lightness interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "cCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Chroma interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "hCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Hue interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "fragCoord",
          "type": "vec2",
          "description": "Fragment coordinates for dithering calculations"
        },
        {
          "name": "resolution",
          "type": "vec2",
          "description": "Screen resolution for dithering calculations"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The resulting RGB color converted from OKLCH with optional dithering applied"
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-bezier",
        "node:color-map",
        "node:bayer-dither",
        "node:oklch-color",
        "type:float",
        "type:vec3"
      ]
    },
    "node:color-map": {
      "title": "Color Map",
      "titleType": "node",
      "category": "Blend",
      "icon": "color-swatch",
      "tagline": "Use this to convert a float value to a grayscale RGB color",
      "description": "Converts a float value to a vec3 RGB color by replicating the float value across all three color channels (R, G, B). This creates a grayscale color where the brightness corresponds to the input value. Useful for visualizing float values as colors, creating grayscale images from scalar data, or preparing float data for color-based operations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The float value to convert to grayscale color (typically 0-1)",
          "suggestedSources": ["type:float", "node:fbm-noise", "node:smoothstep", "node:sine", "node:distance", "node:audio-remap"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The grayscale RGB color (all channels set to the input value)",
          "suggestedTargets": ["node:final-output", "node:mix", "node:blend-mode", "node:tone-mapping", "node:glow-bloom"]
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-bezier",
        "node:oklch-color-map-threshold",
        "type:float",
        "type:vec3"
      ]
    },
    "node:glow-bloom": {
      "title": "Glow",
      "titleType": "node",
      "category": "Effects",
      "icon": "glow",
      "tagline": "Perfect for adding edge glow and bloom effects to enhance bright areas and create atmospheric lighting",
      "description": "Adds edge glow and bloom effects to enhance existing elements by detecting bright areas above a threshold and applying an intensity-based glow. The effect works by identifying pixels that exceed the glow threshold, then amplifying them with a configurable intensity and strength. This creates a soft, atmospheric glow around bright elements, ideal for creating neon effects, magical auras, or enhancing highlights. The glow radius parameter is reserved for future multi-pass implementations that would provide more accurate blur-based bloom.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply glow effects to",
          "suggestedSources": ["node:color-map", "node:oklch-color-map-bezier", "node:mix", "node:blend-mode"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with glow and bloom effects applied",
          "suggestedTargets": ["node:final-output", "node:edge-detection", "node:color-grading", "node:chromatic-aberration"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:blur",
        "node:edge-detection",
        "node:color-grading"
      ]
    },
    "node:blur": {
      "title": "Blur",
      "titleType": "node",
      "category": "Effects",
      "icon": "blur-circle",
      "tagline": "Ideal for creating depth of field, motion blur, and softening effects",
      "description": "Applies blur effects to soften and smooth the input image. The node supports multiple blur types: Gaussian (uniform blur in all directions), directional (blur along a specific angle), and radial (blur radiating from a center point). The current implementation uses a simplified softening approximation since full blur requires texture sampling of neighboring pixels. The blur amount controls the intensity of the softening effect, while the radius parameter is reserved for future multi-pass implementations that would provide true blur with proper sampling.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to blur",
          "suggestedSources": ["node:glow-bloom", "node:color-map", "node:mix", "node:edge-detection"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The blurred color output",
          "suggestedTargets": ["node:final-output", "node:glow-bloom", "node:edge-detection"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:glow-bloom",
        "node:edge-detection"
      ]
    },
    "node:edge-detection": {
      "title": "Edge Detection",
      "titleType": "node",
      "category": "Effects",
      "icon": "focus",
      "tagline": "Use this to detect edges and create outline effects for structural definition and stylized rendering",
      "description": "Detects edges in the input image and creates outline effects by identifying areas where the value crosses a threshold. The effect uses a threshold-based approach with smoothstep interpolation to create soft edge transitions. Edge width controls how gradual the edge detection is, while intensity and strength control the visual impact of the detected edges. This is useful for creating stylized outlines, enhancing structural definition, or creating cartoon-like rendering effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to detect edges in",
          "suggestedSources": ["node:glow-bloom", "node:color-map", "node:blur", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with edge detection effects applied",
          "suggestedTargets": ["node:final-output", "node:block-edge-brightness", "node:mix", "node:color-grading"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:glow-bloom",
        "node:blur",
        "node:block-edge-brightness"
      ]
    },
    "node:chromatic-aberration": {
      "title": "Chromatic Aberration",
      "titleType": "node",
      "category": "Effects",
      "icon": "rgb-split",
      "tagline": "Perfect for creating stylized color fringing effects and lens distortion artifacts",
      "description": "Separates RGB channels to create stylized color fringing effects that simulate chromatic aberration found in camera lenses. The effect shifts red and blue channels relative to the green channel based on distance from a center point and direction. This creates colorful fringes around edges, particularly useful for creating retro or glitch aesthetics. The strength controls the amount of separation, while the falloff parameter controls how the effect diminishes with distance from the center. The current implementation uses an approximation since full chromatic aberration requires texture sampling of RGB channels separately.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply chromatic aberration to",
          "suggestedSources": ["node:glow-bloom", "node:color-map", "node:blur", "node:mix", "node:edge-detection"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with RGB channel separation applied",
          "suggestedTargets": ["node:final-output", "node:rgb-separation", "node:scanlines", "node:block-color-glitch"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:rgb-separation",
        "node:block-color-glitch"
      ]
    },
    "node:color-grading": {
      "title": "Color Grading",
      "titleType": "node",
      "category": "Effects",
      "icon": "color-palette",
      "tagline": "Ideal for fine control over color curves and levels for professional color adjustment",
      "description": "Provides comprehensive color grading controls for final color adjustment, including separate adjustments for shadows, midtones, and highlights. The node applies color curve adjustments to different luminance ranges, allowing you to warm up shadows, adjust midtone saturation, or cool down highlights independently. Additionally, it includes a levels adjustment system with input/output black/white points and gamma correction for precise contrast and brightness control. This is essential for achieving professional color grading and matching specific color aesthetics.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply color grading to",
          "suggestedSources": ["node:glow-bloom", "node:color-map", "node:tone-mapping", "node:mix", "node:blend-mode"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color-graded output with adjusted curves and levels",
          "suggestedTargets": ["node:final-output", "node:tone-mapping", "node:chromatic-aberration"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:tone-mapping",
        "node:oklch-color-map-bezier",
        "node:oklch-color-map-threshold"
      ]
    },
    "node:rgb-separation": {
      "title": "RGB Separation",
      "titleType": "node",
      "category": "Effects",
      "icon": "rgb-split",
      "tagline": "Use this for advanced RGB channel separation with independent X/Y offsets per channel for glitch effects",
      "description": "Provides advanced RGB channel separation with independent X and Y offsets for each color channel (red, green, blue). This creates sophisticated glitch effects by shifting each channel in different directions, resulting in colorful separation artifacts. Unlike simple chromatic aberration, this node allows precise control over each channel's offset independently, enabling complex glitch patterns. The strength parameter controls the overall intensity of the separation effect. This is particularly effective for creating digital glitch aesthetics, VHS-style artifacts, or experimental visual effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to separate RGB channels from",
          "suggestedSources": ["node:color-map", "node:glow-bloom", "node:blur", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with RGB channel separation applied",
          "suggestedTargets": ["node:final-output", "node:chromatic-aberration", "node:block-color-glitch"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:chromatic-aberration",
        "node:block-color-glitch",
        "node:scanlines"
      ]
    },
    "node:scanlines": {
      "title": "Scanlines",
      "titleType": "node",
      "category": "Effects",
      "icon": "scanline",
      "tagline": "Perfect for simulating CRT monitor artifacts and retro digital display effects",
      "description": "Adds horizontal scanline overlay effects that simulate CRT monitor displays or digital display artifacts. The effect creates repeating horizontal lines across the image with configurable frequency (line spacing), thickness, and opacity. The scanlines can be static or animated with time-based scrolling for authentic retro aesthetics. This is ideal for creating nostalgic video game aesthetics, retro computing visuals, or adding vintage character to modern graphics. The time speed and offset parameters allow for animated scanline scrolling effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply scanlines to",
          "suggestedSources": ["node:color-map", "node:glow-bloom", "node:chromatic-aberration", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with scanline overlay applied",
          "suggestedTargets": ["node:final-output", "node:rgb-separation", "node:block-color-glitch"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:rgb-separation",
        "node:block-color-glitch",
        "node:time"
      ]
    },
    "node:block-edge-brightness": {
      "title": "Edge Brightness",
      "titleType": "node",
      "category": "Effects",
      "icon": "brightness",
      "tagline": "Ideal for adding brightness variation at block edges, typically used with block-displacement for glitch effects",
      "description": "Adds brightness variation at block edges, creating visual emphasis on block boundaries. This effect is designed to work in conjunction with block-displacement nodes, matching their block structure parameters (count, direction, spacing chaos) to create cohesive glitch effects. The node detects block boundaries and applies configurable brightness adjustments at the edges, with smooth transitions controlled by the edge width parameter. This creates a distinctive glitch aesthetic where block boundaries are highlighted, enhancing the visual impact of block-based distortions. The effect supports both horizontal and vertical block orientations.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply block edge brightness to",
          "suggestedSources": ["node:edge-detection", "node:color-map", "node:block-color-glitch", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with brightness variation at block edges",
          "suggestedTargets": ["node:block-color-glitch", "node:final-output", "node:mix", "node:chromatic-aberration"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:block-color-glitch",
        "node:edge-detection"
      ]
    },
    "node:block-color-glitch": {
      "title": "Block Color Glitch",
      "titleType": "node",
      "category": "Effects",
      "icon": "glitch",
      "tagline": "Perfect for applying color-based visual glitches using block structure for digital artifact effects",
      "description": "Applies color-based visual glitches using a block structure system. The node can operate in two modes: pre-color-mapping (modifies the result value before color mapping) or post-color-mapping (modifies RGB colors after color mapping). It offers multiple glitch effects including invert, brightness shift, threshold offset, RGB separation, hue rotation, saturation shift, color tint, and noise injection. The block parameters are automatically synced from block-displacement nodes when present. You can select which blocks are affected (all, small only, or large only) and control the intensity and amount of each effect. This creates sophisticated digital glitch aesthetics with precise control over the visual artifacts.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply block glitch effects to",
          "suggestedSources": ["node:color-map", "node:edge-detection", "node:block-edge-brightness", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with block-based glitch effects applied",
          "suggestedTargets": ["node:final-output", "node:chromatic-aberration", "node:rgb-separation", "node:scanlines"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:block-edge-brightness",
        "node:rgb-separation",
        "node:chromatic-aberration"
      ]
    },
    "node:normal-mapping": {
      "title": "Normal Mapping",
      "titleType": "node",
      "category": "Effects",
      "icon": "normal-map",
      "tagline": "Use this to simulate surface detail using normal mapping for added depth and texture",
      "description": "Simulates surface detail and texture using normal mapping techniques. The node calculates surface normals from the input pattern and applies directional lighting to create the illusion of depth and three-dimensional surface detail. It uses a simplified gradient-based approximation to calculate normals, then applies lighting based on a configurable light direction. The normal scale controls the frequency of the surface detail, while strength controls how much the lighting effect influences the final output. This is useful for adding texture and depth to flat patterns, creating the appearance of embossed or engraved surfaces.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply normal mapping to",
          "suggestedSources": ["node:fbm-noise", "node:simplex-noise", "node:color-map", "node:hexagonal-grid"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with normal mapping and lighting applied",
          "suggestedTargets": ["node:lighting-shading", "node:final-output", "node:dot-product"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:lighting-shading",
        "node:dot-product"
      ]
    },
    "node:lighting-shading": {
      "title": "Lighting",
      "titleType": "node",
      "category": "Effects",
      "icon": "light",
      "tagline": "Ideal for adding directional or point lighting to create depth and dimension",
      "description": "Adds directional or point lighting to create depth and dimension in the scene. The node supports two light types: directional (parallel light rays from a specific direction, like sunlight) and point (radial light emanating from a specific position with distance-based falloff). It calculates surface normals from the input pattern and applies lighting calculations based on the light direction or position. Ambient lighting provides a base illumination level, while intensity controls the strength of the directional or point light. The light color can be customized to create warm or cool lighting effects. This is essential for creating three-dimensional appearance and depth in flat patterns.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply lighting to",
          "suggestedSources": ["node:normal-mapping", "node:fbm-noise", "node:color-map", "node:hexagonal-grid"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with lighting and shading applied",
          "suggestedTargets": ["node:final-output", "node:mix", "node:normal-mapping"]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:normal-mapping",
        "node:dot-product",
        "node:normalize"
      ]
    },
    "node:translate": {
      "title": "Translate",
      "titleType": "node",
      "category": "Distort",
      "icon": "arrow-move-right",
      "tagline": "Perfect for shifting coordinates by a fixed offset in X and Y directions",
      "description": "Translates (moves) 2D coordinates by adding X and Y offset values. This is useful for panning textures, shifting patterns, or creating parallax effects. The translation is applied by adding the offset vector to the input coordinates.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to translate",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:scale", "node:rotate", "node:polar-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The translated coordinates with X and Y offsets applied",
          "suggestedTargets": ["node:scale", "node:rotate", "node:fbm-noise", "node:simplex-noise", "node:hexagonal-grid", "node:distance"]
        }
      ],
      "relatedItems": [
        "node:rotate",
        "node:scale",
        "type:vec2",
        "node:uv-coordinates"
      ]
    },
    "node:rotate": {
      "title": "Rotate",
      "titleType": "node",
      "category": "Distort",
      "icon": "rotate",
      "tagline": "Ideal for rotating coordinates around a center point by a specified angle",
      "description": "Rotates 2D coordinates around a specified center point by a given angle in radians. Uses standard rotation matrix calculations to transform the input coordinates. The rotation is counter-clockwise for positive angles. You can control both the rotation angle and the pivot point (center) of rotation.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to rotate",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale", "node:polar-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The rotated coordinates around the specified center point",
          "suggestedTargets": ["node:translate", "node:scale", "node:fbm-noise", "node:kaleidoscope", "node:hexagonal-grid"]
        }
      ],
      "relatedItems": [
        "node:translate",
        "node:scale",
        "type:vec2",
        "node:sine",
        "node:cosine"
      ]
    },
    "node:scale": {
      "title": "Scale",
      "titleType": "node",
      "category": "Distort",
      "icon": "arrow-autofit-height",
      "tagline": "Use this to scale coordinates around a center point with independent X and Y scaling",
      "description": "Scales 2D coordinates around a specified center point with independent X and Y scale factors. Values greater than 1.0 enlarge, values less than 1.0 shrink. The scaling is applied relative to the center point, so coordinates are first offset from the center, scaled, then offset back. This allows for non-uniform scaling (different X and Y values) and precise control over the scaling origin.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to scale",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:rotate", "node:polar-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The scaled coordinates around the specified center point",
          "suggestedTargets": ["node:translate", "node:rotate", "node:fbm-noise", "node:simplex-noise", "node:hexagonal-grid", "node:wave-patterns"]
        }
      ],
      "relatedItems": [
        "node:translate",
        "node:rotate",
        "type:vec2",
        "node:multiply"
      ]
    },
    "node:polar-coordinates": {
      "title": "Polar Coords",
      "titleType": "node",
      "category": "Distort",
      "icon": "spiral",
      "tagline": "Perfect for converting Cartesian coordinates to polar coordinates, enabling radial and rotational effects",
      "description": "Converts 2D Cartesian coordinates to polar coordinates (angle and radius), applies scaling and rotation transformations, then converts back to Cartesian. This enables radial effects, circular patterns, and rotational distortions. You can control the center point, angular scale, radial scale, and rotation. The conversion allows for effects that are naturally expressed in polar space, such as radial gradients, circular patterns, and rotational symmetries.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D Cartesian coordinates to convert",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale", "node:rotate"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The transformed coordinates after polar conversion, scaling, and rotation",
          "suggestedTargets": ["node:rings", "node:kaleidoscope", "node:twist-distortion", "node:arc-tangent-2", "node:length"]
        }
      ],
      "relatedItems": [
        "node:rotate",
        "node:scale",
        "type:vec2",
        "node:arc-tangent-2",
        "node:length"
      ]
    },
    "node:kaleidoscope": {
      "title": "Kaleidoscope",
      "titleType": "node",
      "category": "Distort",
      "icon": "ikosaedr",
      "tagline": "Ideal for creating symmetric patterns by mirroring and reflecting sections of the image",
      "description": "Creates kaleidoscope effects by dividing the coordinate space into segments and mirroring each segment to create symmetric patterns. The node calculates the angle and radius from the center point, determines which segment the coordinate falls into, and mirrors coordinates in the second half of each segment to the first half. This creates beautiful radial symmetry patterns. You can control the number of segments (2-32), the center point, and rotation offset.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply kaleidoscope transformation to",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:polar-coordinates", "node:rotate", "node:translate"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The mirrored coordinates creating symmetric kaleidoscope patterns",
          "suggestedTargets": ["node:fbm-noise", "node:simplex-noise", "node:hexagonal-grid", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:polar-coordinates",
        "node:rotate",
        "type:vec2",
        "node:arc-tangent-2"
      ]
    },
    "node:twist-distortion": {
      "title": "Twist",
      "titleType": "node",
      "category": "Distort",
      "icon": "spiral",
      "tagline": "Use this to apply rotational distortion around a center point, creating spiral and twist effects",
      "description": "Applies rotational distortion (twist) around a specified center point, creating spiral and vortex effects. The twist amount varies based on distance from the center, with stronger effects near the center that fall off with distance. The node calculates the angle of each point relative to the center, adds a twist amount based on distance and strength parameters, then reconstructs the position. You can control the center point, twist strength, radius of effect, falloff rate, and optional time-based animation.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply twist distortion to",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:polar-coordinates", "node:rotate", "node:translate"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The twisted coordinates with rotational distortion applied",
          "suggestedTargets": ["node:fbm-noise", "node:simplex-noise", "node:wave-patterns", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:rotate",
        "node:polar-coordinates",
        "type:vec2",
        "node:smoothstep",
        "node:arc-tangent-2"
      ]
    },
    "node:turbulence": {
      "title": "Turbulence",
      "titleType": "node",
      "category": "Distort",
      "icon": "noise",
      "tagline": "Perfect for applying multi-stage coordinate warping to create complex, organic distortions",
      "description": "Applies multi-stage domain warping using iterative noise-based distortions. The node performs multiple iterations of noise sampling at different scales, accumulating distortions to create complex, organic-looking warping effects. Each iteration uses a different scale (powers of 2), creating fractal-like distortion patterns. The effect can be animated over time and controlled through scale, strength, number of iterations, and time-based parameters. This creates fluid, turbulent distortions similar to water, smoke, or heat haze effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply turbulence distortion to",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:fbm-noise", "node:vector-field"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The warped coordinates after multi-stage turbulence distortion",
          "suggestedTargets": ["node:fbm-noise", "node:simplex-noise", "node:color-map", "node:translate"]
        }
      ],
      "relatedItems": [
        "node:vector-field",
        "type:vec2",
        "node:multiply",
        "node:time"
      ]
    },
    "node:vector-field": {
      "title": "Vector Field",
      "titleType": "node",
      "category": "Distort",
      "icon": "arrow-up-right",
      "tagline": "Ideal for creating warping effects using a vector field that distorts UV coordinates",
      "description": "Applies vector field-based distortion to coordinates, creating complex warping effects. The node generates a vector field using trigonometric functions with configurable frequencies, then uses this field to offset coordinates. The vector field includes harmonic layers for complexity, radial strength for distance-based effects, and can be animated over time. The distortion is calculated using dot products and cross products (2D equivalent) to create directional warping. This creates flowing, dynamic distortions that can simulate fluid motion, magnetic fields, or abstract warping effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply vector field distortion to",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:turbulence", "node:normalize"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The distorted coordinates after vector field transformation",
          "suggestedTargets": ["node:turbulence", "node:fbm-noise", "node:translate", "node:color-map"]
        }
      ],
      "relatedItems": [
        "node:turbulence",
        "node:translate",
        "type:vec2",
        "node:dot-product",
        "node:cosine",
        "node:sine"
      ]
    },
    "node:fbm-noise": {
      "title": "fBm Noise",
      "titleType": "node",
      "category": "Patterns",
      "icon": "noise",
      "tagline": "Perfect for generating fractal Brownian motion noise patterns for organic textures and backgrounds",
      "description": "Generates fractal Brownian motion (fBm) noise by combining multiple octaves of noise at different scales and frequencies. This creates organic, natural-looking patterns that are ideal for textures, backgrounds, and procedural content. The node uses multiple layers of noise with configurable scale, octaves (number of layers), lacunarity (frequency multiplier between octaves), and gain (amplitude multiplier). The result can be animated over time for dynamic effects. fBm noise is particularly useful for creating terrain-like patterns, clouds, or any natural-looking variation.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the noise pattern",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale", "node:polar-coordinates"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The fBm noise value (typically 0.0 to 1.0 range)",
          "suggestedTargets": ["node:color-map", "node:mix", "node:smoothstep", "node:remap", "node:gradient-mask", "node:translate"]
        }
      ],
      "relatedItems": [
        "node:simplex-noise",
        "node:voronoi-noise",
        "type:vec2",
        "node:time"
      ]
    },
    "node:rings": {
      "title": "Rings",
      "titleType": "node",
      "category": "Patterns",
      "icon": "ring",
      "tagline": "Perfect for creating concentric ring patterns with customizable spacing and falloff",
      "description": "Generates concentric ring patterns radiating from a center point. The rings are created by calculating the distance from the center and applying a repeating pattern with configurable frequency and falloff. You can control the center position, ring count (frequency), ring width, and falloff curve to create various effects from sharp concentric circles to soft radial gradients. This is ideal for creating ripple effects, target patterns, or radial organizational structures.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate rings from",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:polar-coordinates", "node:translate", "node:distance"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The ring pattern value (typically 0.0 to 1.0 range)",
          "suggestedTargets": ["node:color-map", "node:mix", "node:smoothstep", "node:gradient-mask"]
        }
      ],
      "relatedItems": [
        "node:polar-coordinates",
        "node:distance",
        "type:vec2",
        "node:fract"
      ]
    },
    "node:sphere-raymarch": {
      "title": "Sphere Raymarch",
      "titleType": "node",
      "category": "Shapes",
      "icon": "sphere",
      "tagline": "Ideal for rendering 3D spheres using raymarching techniques for volumetric effects",
      "description": "Renders 3D spheres using raymarching, a technique that marches rays through space to find intersections with the sphere surface. This creates volumetric, three-dimensional sphere shapes that can be positioned, scaled, and rotated in 3D space. The node calculates ray-sphere intersections and applies lighting and shading to create realistic 3D appearance. You can control the sphere's position, size, and rotation, as well as lighting parameters. This is essential for creating 3D geometric shapes in a 2D shader environment.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to raymarch from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The raymarched sphere result (distance or surface value)"
        }
      ],
      "relatedItems": [
        "node:box-torus-sdf",
        "node:distance",
        "type:vec2",
        "node:normalize"
      ]
    },
    "node:fractal": {
      "title": "Fractal",
      "titleType": "node",
      "category": "Patterns",
      "icon": "sparkles-2",
      "tagline": "Perfect for generating complex fractal patterns with self-similar structures at multiple scales",
      "description": "Generates fractal patterns by iteratively applying transformations and combining results at different scales. Fractals exhibit self-similarity, meaning patterns repeat at different scales, creating complex, organic-looking structures. The node uses iterative algorithms to create these patterns, with configurable iterations, scale factors, and transformation parameters. Fractals are ideal for creating natural-looking patterns, abstract art, or complex geometric structures that would be difficult to create manually.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the fractal pattern from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The fractal pattern value"
        }
      ],
      "relatedItems": [
        "node:fbm-noise",
        "node:turbulence",
        "type:vec2",
        "node:time"
      ]
    },
    "node:voronoi-noise": {
      "title": "Voronoi Noise",
      "titleType": "node",
      "category": "Patterns",
      "icon": "noise",
      "tagline": "Ideal for creating cellular patterns and organic-looking textures with distinct regions",
      "description": "Generates Voronoi (cellular) noise patterns by dividing space into regions based on proximity to seed points. Each region contains all points closest to a particular seed, creating distinct cellular structures. The node can output various Voronoi features including the distance to the nearest seed, distance to the second nearest (for edges), or the seed ID. Voronoi patterns are excellent for creating organic textures, cellular structures, cracked surfaces, or abstract geometric patterns. The pattern can be animated over time for dynamic effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the Voronoi pattern"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The Voronoi noise value (distance or feature value)"
        }
      ],
      "relatedItems": [
        "node:fbm-noise",
        "node:simplex-noise",
        "node:distance",
        "type:vec2",
        "node:time"
      ]
    },
    "node:wave-patterns": {
      "title": "Wave Patterns",
      "titleType": "node",
      "category": "Patterns",
      "icon": "wave",
      "tagline": "Perfect for creating animated wave patterns with customizable frequency, amplitude, and direction",
      "description": "Generates wave patterns using trigonometric functions (sine, cosine) to create repeating, oscillating patterns. The waves can be oriented in different directions, have configurable frequency (how many waves), amplitude (wave height), and can be animated over time. Multiple wave layers can be combined to create complex interference patterns. This is ideal for creating water effects, animated backgrounds, or any repeating wave-like patterns. The waves can be linear (traveling in one direction) or radial (expanding from a center point).",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate waves from",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale", "node:time"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The wave pattern value (typically -1.0 to 1.0 range)",
          "suggestedTargets": ["node:color-map", "node:mix", "node:smoothstep", "node:translate", "node:blending-modes"]
        }
      ],
      "relatedItems": [
        "node:sine",
        "node:cosine",
        "node:time",
        "type:vec2"
      ]
    },
    "node:gradient-mask": {
      "title": "Gradient Mask",
      "titleType": "node",
      "category": "Mask",
      "icon": "mask",
      "tagline": "Ideal for creating smooth gradient masks for selective effect application and blending",
      "description": "Creates gradient masks that can selectively apply or blend effects in specific regions. The node supports multiple mask types: radial (circular gradients from a center point), linear (gradients along a direction), and elliptical (oval-shaped gradients). Each mask type has configurable position, size, falloff, and strength parameters. The mask outputs a value from 0.0 (fully masked) to 1.0 (fully visible), allowing smooth transitions. This is essential for creating vignettes, spotlight effects, or any region-based effect application.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply the gradient mask to",
          "suggestedSources": ["node:color-map", "node:oklch-color-map-bezier", "node:mix", "node:blend-mode"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The masked color output with gradient blending applied",
          "suggestedTargets": ["node:final-output", "node:mix", "node:blend-mode", "node:glow-bloom"]
        }
      ],
      "relatedItems": [
        "node:compare",
        "node:select",
        "type:vec4",
        "node:distance"
      ]
    },
    "node:hexagonal-grid": {
      "title": "Hexagons",
      "titleType": "node",
      "category": "Patterns",
      "icon": "hexagon",
      "tagline": "Perfect for creating hexagonal grid patterns for tiling, cellular structures, or game board layouts",
      "description": "Generates a seamless, regular hexagonal tiling pattern. Control the cell size, the gap (margin) between cells, and a per-cell rotation (rotates each hexagon’s shape without rotating the grid). A separate grid rotation rotates the overall tiling, and intensity controls the output strength.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the hexagonal grid from",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale", "node:rotate"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The hexagonal grid pattern value",
          "suggestedTargets": ["node:color-map", "node:mix", "node:smoothstep", "node:gradient-mask"]
        }
      ],
      "relatedItems": [
        "node:plane-grid",
        "node:fract",
        "type:vec2"
      ]
    },
    "node:simplex-noise": {
      "title": "Simplex Noise",
      "titleType": "node",
      "category": "Patterns",
      "icon": "noise",
      "tagline": "Ideal for generating high-quality, smooth noise patterns with better computational efficiency than Perlin noise",
      "description": "Generates Simplex noise, an improved version of Perlin noise that provides smoother, higher-quality results with better computational performance. Simplex noise uses a different grid structure (simplices instead of hypercubes) that eliminates directional artifacts and provides more uniform distribution. The noise is smoother and more natural-looking than traditional Perlin noise, making it ideal for textures, terrain generation, or any application requiring high-quality procedural noise. The pattern can be scaled, offset, and animated over time.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the Simplex noise",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale", "node:time"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The Simplex noise value (typically -1.0 to 1.0 range)",
          "suggestedTargets": ["node:color-map", "node:mix", "node:fbm-noise", "node:smoothstep", "node:remap"]
        }
      ],
      "relatedItems": [
        "node:fbm-noise",
        "node:voronoi-noise",
        "type:vec2",
        "node:time"
      ]
    },
    "node:particle-system": {
      "title": "Particle System",
      "titleType": "node",
      "category": "Patterns",
      "icon": "particle",
      "tagline": "Perfect for creating animated particle effects with configurable movement, size, and behavior",
      "description": "Generates animated particle systems that create dynamic, moving particle effects. Each particle has position, velocity, size, and lifetime properties that evolve over time. The particles can be rendered as points, circles, or other shapes, and can interact with forces, boundaries, or other particles. The system supports configurable particle count, spawn rate, initial velocity, gravity, and various behaviors. This is ideal for creating effects like sparks, smoke, rain, or any collection of moving elements.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to render particles at"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The particle system output (particle presence or density)"
        }
      ],
      "relatedItems": [
        "node:time",
        "node:distance",
        "type:vec2"
      ]
    },
    "node:plane-grid": {
      "title": "Grid",
      "titleType": "node",
      "category": "Patterns",
      "icon": "grid",
      "tagline": "Ideal for creating regular square grid patterns for tiling, organization, or structural elements",
      "description": "Generates regular square grid patterns by dividing space into uniform cells. The grid creates a checkerboard or lattice-like pattern that can be used for tiling, organization, or as a structural element in compositions. You can control the grid cell size, line thickness, and offset. The grid can output cell IDs, distance to grid lines, or edge detection. This is useful for creating game boards, measurement grids, or any application requiring regular spatial division.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the grid from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The grid pattern value"
        }
      ],
      "relatedItems": [
        "node:hexagonal-grid",
        "node:fract",
        "type:vec2"
      ]
    },
    "node:box-torus-sdf": {
      "title": "SDF",
      "titleType": "node",
      "category": "Shapes",
      "icon": "box",
      "tagline": "Perfect for rendering 3D box and torus shapes using signed distance fields (SDF) for raymarching",
      "description": "Renders 3D box and torus shapes using signed distance fields (SDF) with raymarching. SDFs define shapes by their distance to the surface, allowing efficient rendering of complex 3D geometry. The node can render boxes (rectangular prisms) and toruses (donut shapes) with configurable size, position, and rotation. SDF raymarching provides smooth, accurate 3D shapes with proper lighting and shading. This is essential for creating 3D geometric primitives in a 2D shader environment.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to raymarch from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The SDF raymarched shape result (signed distance value)"
        }
      ],
      "relatedItems": [
        "node:sphere-raymarch",
        "node:distance",
        "type:vec2",
        "node:normalize"
      ]
    },
    "node:blending-modes": {
      "title": "Blending Modes",
      "titleType": "node",
      "category": "Effects",
      "icon": "blend-mode",
      "tagline": "Ideal for combining elements using various blend modes like multiply, screen, overlay, and more",
      "description": "Applies blending modes to combine two color inputs, similar to layer blending in image editing software. The node supports multiple blend modes including Normal, Multiply, Screen, Overlay, Soft Light, Hard Light, Color Dodge, Color Burn, and more. Each mode produces different visual effects when combining colors. The blend can be controlled by opacity, and the blend source can come from the second input, a constant value, noise, or wave patterns. This is essential for creating complex compositing effects and layering multiple elements together.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The base color to blend with the blend input"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The blended color result"
        }
      ],
      "relatedItems": [
        "node:blend-mode",
        "node:mix",
        "type:vec4"
      ]
    },
    "node:block-displacement": {
      "title": "Block Displacement",
      "titleType": "node",
      "category": "Distort",
      "icon": "displacement",
      "tagline": "Perfect for creating glitch effects with variable-size blocks that displace coordinates",
      "description": "Creates glitch effects by dividing the coordinate space into variable-size blocks and applying displacement offsets. Larger blocks receive less offset while smaller blocks receive more offset, creating a distinctive glitch aesthetic. The blocks can be oriented horizontally or vertically, and the block boundaries, sizes, and offsets are determined by configurable parameters including block count, spacing chaos, and time-based animation. This effect is commonly used with block-color-glitch and block-edge-brightness nodes to create cohesive glitch compositions.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply block displacement to"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The displaced coordinates after block transformation"
        }
      ],
      "relatedItems": [
        "node:block-color-glitch",
        "node:block-edge-brightness",
        "type:vec2",
        "node:time"
      ]
    },
    "node:compare": {
      "title": "Compare",
      "titleType": "node",
      "category": "Mask",
      "icon": "compare",
      "tagline": "Perfect for comparing two values and outputting binary results for conditional logic",
      "description": "Compares two input values using a selected comparison operation and outputs 1.0 if the condition is true, 0.0 otherwise. The available operations include equal (==), not equal (!=), less than (<), less than or equal (<=), greater than (>), and greater than or equal (>=). This is essential for creating conditional logic, thresholds, and binary masks based on value comparisons. The output can be used to drive other nodes or create selective effects.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to compare",
          "suggestedSources": ["type:float", "node:fbm-noise", "node:distance", "node:sine", "node:uv-coordinates"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to compare against",
          "suggestedSources": ["type:float", "node:constant-float", "node:remap", "node:smoothstep"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "1.0 if the comparison is true, 0.0 otherwise",
          "suggestedTargets": ["node:select", "node:mix", "node:step", "node:gradient-mask"]
        }
      ],
      "relatedItems": [
        "node:select",
        "node:step",
        "type:float"
      ]
    },
    "node:select": {
      "title": "Select",
      "titleType": "node",
      "category": "Mask",
      "icon": "select",
      "tagline": "Ideal for choosing between two values based on a condition for conditional routing",
      "description": "Selects between two input values based on a condition. If the condition is greater than 0.5, it returns the true value; otherwise, it returns the false value. This creates a simple conditional branch that allows routing different values through the node graph based on conditions. The condition is typically a float value from 0.0 to 1.0, where values above 0.5 are considered true. This is useful for creating conditional effects, switching between different inputs, or implementing if-else logic in shader graphs.",
      "inputs": [
        {
          "name": "condition",
          "type": "float",
          "description": "The condition value (values > 0.5 select trueValue)",
          "suggestedSources": ["type:float", "node:compare", "node:step", "node:smoothstep", "node:fbm-noise"]
        },
        {
          "name": "trueValue",
          "type": "float",
          "description": "The value returned when condition is true",
          "suggestedSources": ["type:float", "node:constant-float", "node:color-map", "node:mix"]
        },
        {
          "name": "falseValue",
          "type": "float",
          "description": "The value returned when condition is false",
          "suggestedSources": ["type:float", "node:constant-float", "node:color-map", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The selected value based on the condition",
          "suggestedTargets": ["node:mix", "node:color-map", "node:final-output", "node:gradient-mask"]
        }
      ],
      "relatedItems": [
        "node:compare",
        "node:mix",
        "type:float"
      ]
    },
    "node:one-minus": {
      "title": "One Minus",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Perfect for inverting values in the 0-1 range (calculates 1.0 - input)",
      "description": "Subtracts the input value from 1.0, effectively inverting values in the 0-1 range. When the input is 0.0, the output is 1.0; when the input is 1.0, the output is 0.0. This is commonly used for inverting masks, flipping gradients, or creating inverse relationships. The operation is equivalent to (1.0 - input) and is a fundamental utility for many shader operations that require inverted values.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to invert (subtract from 1.0)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The inverted value (1.0 - input)"
        }
      ],
      "relatedItems": [
        "node:negate",
        "node:subtract",
        "type:float"
      ]
    },
    "node:negate": {
      "title": "Negate",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Use this to negate (flip sign) of a value, converting positive to negative and vice versa",
      "description": "Negates the input value by multiplying it by -1.0, effectively flipping its sign. Positive values become negative, and negative values become positive. Zero remains zero. This is useful for reversing directions, inverting offsets, or creating mirror effects. The operation is equivalent to (-input) and is a fundamental utility for many mathematical operations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to negate"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The negated value (-input)"
        }
      ],
      "relatedItems": [
        "node:one-minus",
        "node:multiply",
        "type:float"
      ]
    },
    "node:reciprocal": {
      "title": "Reciprocal",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Ideal for calculating the reciprocal (1.0 / input) for division operations",
      "description": "Calculates the reciprocal of the input value by dividing 1.0 by the input. The reciprocal of a number is its multiplicative inverse, so multiplying a value by its reciprocal equals 1.0. This is useful for inverting scales, converting rates to periods, or performing division when you need to multiply by the inverse. Be careful with values near zero, as the reciprocal approaches infinity.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to calculate the reciprocal of (must not be zero)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The reciprocal value (1.0 / input)"
        }
      ],
      "relatedItems": [
        "node:divide",
        "node:multiply",
        "type:float"
      ]
    },
    "node:remap": {
      "title": "Remap",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Perfect for remapping values from one range to another with linear interpolation",
      "description": "Remaps a value from an input range to an output range using linear interpolation. The node takes the input value, determines its position within the input range (inMin to inMax), and maps that position to the corresponding value in the output range (outMin to outMax). This is essential for converting values between different scales, normalizing data, or adjusting value ranges to fit specific requirements. The remapping preserves the relative position of the value within its range.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to remap from the input range",
          "suggestedSources": ["type:float", "node:fbm-noise", "node:sine", "node:distance", "node:audio-analyzer"]
        },
        {
          "name": "inMin",
          "type": "float",
          "description": "The minimum value of the input range",
          "suggestedSources": ["type:float", "node:constant-float"]
        },
        {
          "name": "inMax",
          "type": "float",
          "description": "The maximum value of the input range",
          "suggestedSources": ["type:float", "node:constant-float"]
        },
        {
          "name": "outMin",
          "type": "float",
          "description": "The minimum value of the output range",
          "suggestedSources": ["type:float", "node:constant-float"]
        },
        {
          "name": "outMax",
          "type": "float",
          "description": "The maximum value of the output range",
          "suggestedSources": ["type:float", "node:constant-float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The remapped value in the output range",
          "suggestedTargets": ["node:mix", "node:color-map", "node:smoothstep", "node:translate", "node:audio-remap"]
        }
      ],
      "relatedItems": [
        "node:mix",
        "node:clamp",
        "type:float"
      ]
    },
    "node:clamp-01": {
      "title": "Clamp 01",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Use this to clamp values to the 0.0-1.0 range, ensuring they stay within valid bounds",
      "description": "Clamps the input value to the range 0.0 to 1.0. Values below 0.0 become 0.0, values above 1.0 become 1.0, and values within the range remain unchanged. This is a specialized version of the clamp node with fixed bounds, commonly used in shader programming. It's equivalent to clamp(input, 0.0, 1.0) and is essential for ensuring values stay within normalized ranges, particularly for colors, masks, and blend factors.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to clamp to 0.0-1.0 range"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The clamped value (between 0.0 and 1.0)"
        }
      ],
      "relatedItems": [
        "node:clamp",
        "node:saturate",
        "type:float"
      ]
    },
    "node:saturate": {
      "title": "Saturate",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Same as Clamp 01, a common shader programming term for clamping to 0-1 range",
      "description": "Saturates the input value by clamping it to the 0.0-1.0 range. This is identical to the Clamp 01 node but uses the common shader programming term 'saturate'. The function ensures values stay within the normalized range, which is essential for color channels, blend factors, and many shader operations. Values below 0.0 become 0.0, values above 1.0 become 1.0, and values within range remain unchanged.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to saturate (clamp to 0.0-1.0)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The saturated value (clamped between 0.0 and 1.0)"
        }
      ],
      "relatedItems": [
        "node:clamp-01",
        "node:clamp",
        "type:float"
      ]
    },
    "node:sign": {
      "title": "Sign",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Ideal for extracting the sign of a value, returning -1.0, 0.0, or 1.0",
      "description": "Returns the sign of the input value: -1.0 for negative values, 0.0 for zero, and 1.0 for positive values. This is useful for determining direction, creating conditional logic based on sign, or extracting the sign component of a value. The sign function is commonly used in mathematical operations where you need to know whether a value is positive or negative without caring about its magnitude.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to get the sign of"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The sign value (-1.0, 0.0, or 1.0)"
        }
      ],
      "relatedItems": [
        "node:absolute",
        "node:negate",
        "type:float"
      ]
    },
    "node:round": {
      "title": "Round",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Perfect for rounding values to the nearest integer for quantization and discrete steps",
      "description": "Rounds the input value to the nearest integer. Values exactly halfway between integers round to the nearest even integer (banker's rounding). This is useful for quantizing values, creating discrete steps, or converting continuous values to integer-like values. Rounding is commonly used for pixel-perfect effects, grid snapping, or creating stepped animations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to round to the nearest integer"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The rounded value (nearest integer)"
        }
      ],
      "relatedItems": [
        "node:floor",
        "node:ceil",
        "node:fract",
        "type:float"
      ]
    },
    "node:truncate": {
      "title": "Truncate",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Use this to truncate (remove fractional part) of a value, rounding towards zero",
      "description": "Truncates the input value by removing its fractional part, effectively rounding towards zero. Positive values are rounded down, and negative values are rounded up (towards zero). This is different from floor, which always rounds down. Truncation is useful for creating discrete values, quantizing, or extracting the integer component of a number. The result is always closer to zero than the input.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to truncate (remove fractional part)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The truncated value (fractional part removed)"
        }
      ],
      "relatedItems": [
        "node:floor",
        "node:round",
        "node:fract",
        "type:float"
      ]
    },
    "node:lerp": {
      "title": "Lerp",
      "titleType": "node",
      "category": "Utilities",
      "icon": "settings-2",
      "tagline": "Linear interpolation (alias for Mix) for smoothly blending between two values",
      "description": "Performs linear interpolation (lerp) between two values, which is identical to the Mix node. When the blend factor (t) is 0.0, it returns the first value (a). When t is 1.0, it returns the second value (b). Values in between are linearly interpolated. The term 'lerp' is commonly used in game development and graphics programming as shorthand for linear interpolation. This node provides the same functionality as Mix but with a different name for familiarity.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value (returned when t = 0.0)",
          "suggestedSources": ["type:float", "node:constant-float", "node:sine", "node:fbm-noise", "node:color-map"]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value (returned when t = 1.0)",
          "suggestedSources": ["type:float", "node:constant-float", "node:sine", "node:fbm-noise", "node:color-map"]
        },
        {
          "name": "t",
          "type": "float",
          "description": "The blend factor (typically 0.0 to 1.0)",
          "suggestedSources": ["type:float", "node:smoothstep", "node:uv-coordinates", "node:audio-remap"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The linearly interpolated value between a and b",
          "suggestedTargets": ["node:final-output", "node:color-map", "node:blend-mode", "node:translate"]
        }
      ],
      "relatedItems": [
        "node:mix",
        "node:smoothstep",
        "type:float"
      ]
    },
    "node:swizzle": {
      "title": "Swizzle",
      "titleType": "node",
      "category": "Utilities",
      "icon": "arrows-right-left",
      "tagline": "Perfect for reordering and rearranging vector components (xy, yx, xyz, etc.)",
      "description": "Reorders and rearranges vector components using swizzle patterns. Swizzling allows you to access vector components in different orders, duplicate components, or extract subsets. Common patterns include 'xy' (extract x and y), 'yx' (swap x and y), 'xyz' (extract first three), 'zyx' (reverse order), 'xyzw' (all components), and 'wzyx' (reverse all). The node supports common 2, 3, and 4 component patterns. This is essential for manipulating vector data, extracting specific components, or reordering coordinates.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input vector to swizzle"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The swizzled vector with reordered components"
        }
      ],
      "relatedItems": [
        "node:split-vector",
        "node:combine-vector",
        "type:vec4"
      ]
    },
    "node:split-vector": {
      "title": "Split Vector",
      "titleType": "node",
      "category": "Utilities",
      "icon": "layers-difference",
      "tagline": "Ideal for splitting a vector into its individual components (x, y, z, w)",
      "description": "Splits a vector into its individual components, outputting each component (x, y, z, w) as separate float outputs. This allows you to access and manipulate individual components of a vector independently. The node takes a vec4 input and outputs four float values representing the x, y, z, and w components. This is essential for extracting specific components, performing per-component operations, or routing individual components to different parts of the node graph.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The vector to split into components",
          "suggestedSources": ["type:vec2", "type:vec3", "type:vec4", "node:uv-coordinates", "node:polar-coordinates", "node:constant-vec2"]
        }
      ],
      "outputs": [
        {
          "name": "x",
          "type": "float",
          "description": "The x component of the input vector",
          "suggestedTargets": ["node:arc-tangent-2", "node:combine-vector", "node:multiply", "node:add"]
        },
        {
          "name": "y",
          "type": "float",
          "description": "The y component of the input vector",
          "suggestedTargets": ["node:arc-tangent-2", "node:combine-vector", "node:multiply", "node:add"]
        },
        {
          "name": "z",
          "type": "float",
          "description": "The z component of the input vector",
          "suggestedTargets": ["node:combine-vector", "node:multiply", "node:color-map"]
        },
        {
          "name": "w",
          "type": "float",
          "description": "The w component of the input vector",
          "suggestedTargets": ["node:combine-vector", "node:mix"]
        }
      ],
      "relatedItems": [
        "node:combine-vector",
        "node:swizzle",
        "type:vec4"
      ]
    },
    "node:combine-vector": {
      "title": "Combine Vector",
      "titleType": "node",
      "category": "Utilities",
      "icon": "layers-union",
      "tagline": "Perfect for combining individual float values into a vector (vec2, vec3, or vec4)",
      "description": "Combines individual float values into a vector. The node takes four float inputs (x, y, z, w) and outputs a vec4, but the output type can be configured to vec2 or vec3 as needed. The compiler handles type promotion/demotion based on how the output is used. This is the inverse operation of Split Vector and is essential for constructing vectors from individual components, creating coordinates from separate values, or assembling color values from individual channels.",
      "inputs": [
        {
          "name": "x",
          "type": "float",
          "description": "The x component of the output vector",
          "suggestedSources": ["type:float", "node:split-vector", "node:constant-float", "node:uv-coordinates"]
        },
        {
          "name": "y",
          "type": "float",
          "description": "The y component of the output vector",
          "suggestedSources": ["type:float", "node:split-vector", "node:constant-float", "node:uv-coordinates"]
        },
        {
          "name": "z",
          "type": "float",
          "description": "The z component of the output vector",
          "suggestedSources": ["type:float", "node:split-vector", "node:constant-float", "node:color-map"]
        },
        {
          "name": "w",
          "type": "float",
          "description": "The w component of the output vector",
          "suggestedSources": ["type:float", "node:split-vector", "node:constant-float"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The combined vector (type promoted/demoted by compiler as needed)",
          "suggestedTargets": ["node:translate", "node:uv-coordinates", "node:mix", "node:split-vector"]
        }
      ],
      "relatedItems": [
        "node:split-vector",
        "node:swizzle",
        "type:vec4"
      ]
    },
    "node:bayer-dither": {
      "title": "Bayer Dither",
      "titleType": "node",
      "category": "Effects",
      "icon": "dither",
      "tagline": "Ideal for applying Bayer dithering to reduce banding artifacts and create ordered dither patterns",
      "description": "Applies Bayer dithering to a float value using fragment coordinates to create an ordered dither pattern. Bayer dithering uses a threshold matrix to add controlled noise that breaks up banding artifacts in gradients and color transitions. The dithering strength and pixel size can be configured to control the intensity and scale of the dither pattern. This is particularly useful for reducing color banding in gradients, especially when working with limited color depth or when creating retro/vintage aesthetics that benefit from dithering artifacts.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The input value to apply dithering to",
          "suggestedSources": ["type:float", "node:color-map", "node:fbm-noise", "node:smoothstep", "node:oklch-color-map-threshold"]
        },
        {
          "name": "fragCoord",
          "type": "vec2",
          "description": "Fragment coordinates for dithering pattern calculation",
          "suggestedSources": ["node:fragment-coordinates", "node:uv-coordinates"]
        },
        {
          "name": "resolution",
          "type": "vec2",
          "description": "Screen resolution for dithering calculations",
          "suggestedSources": ["node:resolution"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The dithered value with Bayer pattern applied",
          "suggestedTargets": ["node:color-map", "node:oklch-color-map-threshold", "node:mix"]
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-threshold",
        "type:float",
        "node:fragment-coordinates"
      ]
    },
    "node:tone-mapping": {
      "title": "Tone Mapping",
      "titleType": "node",
      "category": "Effects",
      "icon": "contrast-2",
      "tagline": "Perfect for adjusting exposure, contrast, and saturation for final color correction",
      "description": "Applies tone mapping adjustments to color values, including exposure (brightness), contrast, and saturation. Exposure multiplies the color values to adjust overall brightness. Contrast centers the values around 0.5 and scales them to increase or decrease contrast. Saturation adjusts color intensity by mixing the color with its luminance (grayscale version). These adjustments are essential for final color correction and achieving the desired look. Tone mapping is typically applied near the end of the rendering pipeline to fine-tune the final appearance.",
      "inputs": [
        {
          "name": "in",
          "type": "vec3",
          "description": "The input RGB color to apply tone mapping to",
          "suggestedSources": ["node:color-map", "node:oklch-color-map-bezier", "node:color-grading", "node:mix", "node:blend-mode"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The tone-mapped color with exposure, contrast, and saturation adjustments",
          "suggestedTargets": ["node:final-output", "node:color-grading"]
        }
      ],
      "relatedItems": [
        "node:color-grading",
        "node:multiply",
        "type:vec3"
      ]
    },
    "node:final-output": {
      "title": "Output",
      "titleType": "node",
      "category": "Output",
      "icon": "screen-share",
      "tagline": "Marks the final output node for the shader, converting input to final color output",
      "description": "Marks the final output node for the shader, indicating where the rendering pipeline ends. This is a terminal node with no outputs - it marks the end of the computation graph. The node accepts a vec3 RGB color input, and the compiler uses this input connection to determine the final shader output. The compiler automatically handles type conversion if a different type is connected (float becomes grayscale, vec2/vec4 are converted appropriately). This node is required in every shader graph to define the final output. Only one Final Output node should be present in a graph, and it serves as the entry point for the compiled shader code.",
      "inputs": [
        {
          "name": "in",
          "type": "vec3",
          "description": "The final RGB color to output (accepts float, vec2, vec3, or vec4 with automatic conversion)",
          "suggestedSources": ["node:color-map", "node:tone-mapping", "node:color-grading", "node:blend-mode", "node:mix", "node:glow-bloom"]
        }
      ],
      "outputs": [],
      "relatedItems": [
        "node:color-map",
        "type:vec3"
      ]
    }
  }
}